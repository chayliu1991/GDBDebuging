# 多进程与多线程

## 多进程调试

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    pid_t pid;

    pid = fork();
    if (pid < 0)
    {
        exit(1);
    }
    else if (pid > 0)
    {
        printf("Parent\n");
        exit(0);
    }
    printf("Child\n");
    return 0;
}
```

### 调试子进程

在调试多进程程序时，gdb 默认会追踪父进程。例如：

```
(gdb) start
Temporary breakpoint 1 at 0x748: file main.cpp, line 8.
Starting program: /mnt/Work/test/main 

Temporary breakpoint 1, main () at main.cpp:8
8           pid = fork();
(gdb) n
Child
9           if (pid < 0)
(gdb) 
13          else if (pid > 0)
(gdb) 
15              printf("Parent\n");
(gdb) 
Parent
16              exit(0);
```

可以看到第 8 行时子进程执行了。

如果要调试子进程，要使用如下命令：

```
set follow-fork-mode child
```

例如：

```
(gdb) set follow-fork-mode child
(gdb) start
Temporary breakpoint 1 at 0x748: file main.cpp, line 8.
Starting program: /mnt/Hello/Work/cy/test/main 

Temporary breakpoint 1, main () at main.cpp:8
8           pid = fork();
(gdb) n
[New process 14735]
Parent
[Switching to process 14735]
main () at main.cpp:9
9           if (pid < 0)
(gdb) n
13          else if (pid > 0)
(gdb) n
18          printf("Child\n");
(gdb) n
Child
19          return 0;
```

可以看到程序执行到第18行：子进程打印 “Child”。

## 多线程调试

```
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <string.h>

void* pthread_run1(void* arg)
{
    (void)arg;

    while(1)
    {
        printf("I am thread1,ID: %lu\n",pthread_self());
        sleep(1);
    }
}

void* pthread_run2(void* arg)
{
    (void)arg;

    while(1)
    {
        printf("I am thread2,ID: %lu\n",pthread_self());
        sleep(1);
    }
}


int main()
{

    pthread_t tid1;
    pthread_t tid2;

    pthread_create(&tid1,NULL,pthread_run1,NULL);
    pthread_create(&tid2,NULL,pthread_run2,NULL);

    printf("I am main thread\n");

    pthread_join(tid1,NULL);
    pthread_join(tid2,NULL);
    return 0;
}
```

编译：

```
g++ -o test test.cpp -g -lpthread
```

编译后执行，查看一下进程和线程 ID：

```
ps -aux | grep test #@ 查看当前的进程
18937  0.0  0.0  23084   872 pts/6    Sl+  22:32   0:00 ./test

ps -aL | grep test #@ 查看当前的轻量级进程
18937 18937 pts/6    00:00:00 test
18937 18938 pts/6    00:00:00 test
18937 18939 pts/6    00:00:00 test

pstree -p 18937 #@ 查看主线程和子线程的关系
test(18937)-+-{test}(18938)
            `-{test}(18939)
```

### 线程栈结构的查看

attach 到已经运行的线程：

```
gdb attach 18937
```

查看进程信息 info inferiors：

```
(gdb) info inferiors  #@ 查看进程信息
  Num  Description       Executable        
* 1    process 18937     /mnt/Work/test 		#@ 只有一个进程
```

查看线程 info threads：

```
(gdb) info threads  #@ 查看线程信息
  Id   Target Id         Frame 
* 1    Thread 0x7f313ce6e740 (LWP 18937) "test" 0x00007f313ca6cd2d in __GI___pthread_timedjoin_ex (threadid=139849443518208, thread_return=0x0, 
    abstime=0x0, block=<optimized out>) at pthread_join_common.c:89
  2    Thread 0x7f313c672700 (LWP 18938) "test" 0x00007f313c7579d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f313c671ea0, 
    remaining=remaining@entry=0x7f313c671ea0) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
  3    Thread 0x7f313be71700 (LWP 18939) "test" 0x00007f313c7579d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f313be70ea0, 
    remaining=remaining@entry=0x7f313be70ea0) at ../sysdeps/unix/sysv/linux/nanosleep.c:28
```

查看当前线程的栈结构 bt，默认是主线程：

```
(gdb) bt  #@ 默认是主线程
#0  0x00007f313ca6cd2d in __GI___pthread_timedjoin_ex (threadid=139849443518208, thread_return=0x0, abstime=0x0, block=<optimized out>)
    at pthread_join_common.c:89
#1  0x0000563b2ab829a0 in main () at test.cpp:41
```

切换线程 thread n (n 表示第几个线程)：

```
(gdb) thread 2			#@ 切换到线程 2
[Switching to thread 2 (Thread 0x7f313c672700 (LWP 18938))]
#0  0x00007f313c7579d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f313c671ea0, remaining=remaining@entry=0x7f313c671ea0)
    at ../sysdeps/unix/sysv/linux/nanosleep.c:28
28      ../sysdeps/unix/sysv/linux/nanosleep.c: No such file or directory.
(gdb) bt	#@ 查看线程2的栈结构
#0  0x00007f313c7579d0 in __GI___nanosleep (requested_time=requested_time@entry=0x7f313c671ea0, remaining=remaining@entry=0x7f313c671ea0)
    at ../sysdeps/unix/sysv/linux/nanosleep.c:28
#1  0x00007f313c7578aa in __sleep (seconds=0) at ../sysdeps/posix/sleep.c:55
#2  0x0000563b2ab828ff in pthread_run1 (arg=0x0) at test.cpp:14
#3  0x00007f313ca6b6db in start_thread (arg=0x7f313c672700) at pthread_create.c:463
#4  0x00007f313c79488f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
```

### 设置线程锁定模式

用 gdb 调试多线程程序时，一旦程序断住，所有的线程都处于暂停状态。此时当你调试其中一个线程时（比如执行 step，next 命令），所有的线程都会同时执行。可以通过 set scheduler 来进行控制：

```
set scheduler-locking   off | on | step  
```

- on：只有当前调试线程运行，其他线程处于暂停状态。
- off：当前调试线程外的其他线程一直在正常运行。
- step：其他线程跟随当前调试线程运行，但具体怎么协同运行，测试中无法体现。

查看当前锁定线程的模式：

```
show scheduler-locking
```

